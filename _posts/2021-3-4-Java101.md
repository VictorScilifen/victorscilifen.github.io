---
layout: posts

alt_title: "Java101"

# optional sub-title below the page title
sub_title: "java101"

# optional intro text below titles, Markdown allowed
introduction: |
    JavaSE 101
categories: Articles
tags: Java
---



# Java SE

## 数据类型

### 基本数据类型

数值类型：

1. byte 1字节

2. short 2字节

3. int 4字节

4. long 8字节 数字后面需要添加L

5. float 4字节 数字后面需要添加F

6. double 8字节

7. char 2字节 字符只有一个字

8. boolean 2字节

   > string不是一种数据类型 string是一个类

### 引用数据类型

1. 接口
2. 类
3. 数组

### 字节和位的关系

位bit 是计算机储存数据的最小单位，10001000是一个8位二进制数

字节byte 是计算机处理数据的最小单位，1字节=8位

### java中表示各种进制

1. 二进制 0b
2. 八进制 0
3. 十六进制 0x

### 强制转换 

1. 所有字符都是数字，可以使用（int）强制转换；
2. ‘\u’ 转义字符
   1. \t 	制表符
   2. \n 换行符
   3. 

```java
int a;
byte b = (byte) a;
```

> 注意小类型向大类型转换会导致内存溢出

### ！注意

浮点数具有 离散、有限、接近、舍入误差、大约、接近但不等于的特性，

***最好完全避免使用浮点数进行比较***

使用Big Decimal数学工具类来修复该可能错误

### @语法糖

```java
if(flag)
  //默认和true比较
```

// 第25集

## 变量

### 类变量

修饰词static

### 实例变量

无修饰词static

从属于类，为初始化为默认值。boolean必须初始化，其余基本类型为0，null

### 局部变量

类中方法体里面的变量

**必须声明和初始化值**

### 程序结构：

1. 属性
2. 变量
3. 方法

## 常量 final

1. 常量名一般适用全大写
2. final 常量值 = 数值
3. final 和 static可以互换位置，**修饰词不区分前后**

## 命名规则

1. 类成员变量 小驼峰
2. 局部变量 小驼峰
3. 常量 全部使用大写字母 下划线
4. 类名 大驼峰
5. 方法名 小驼峰

## 运算符

### 算数运算符

1. % 模（取余）

### 赋值运算符

### 关系运算符

<=,>=,==,!=

instanceof

### 逻辑运算符

&&和

！非

｜｜或

### 位运算符

### 条件运算符

？：

### 扩展赋值运算符

+=，-=，*=，/=

### 运算逻辑

1. 有long的结构是long
2. 有double的都是double

## 包机制

1. 包命名用公司域名倒名
2. 包的倒入使用package
3. 类的导入使用import
4. 类的通配符*

## JavaDoc

1. @author
2. @version
3. @since jdk版本
4. @param
5. @return
6. @throws

> Javadoc -encoding UTF-8 -charset UTF-8

# Java Packages

## Scanner

常见一个scanner对象

```java
Scanner s = new Scanner(System.in);
```

判断用户有没有输入字符串

```java
if(scanner.hasNext()){
  String str = scanner.next();
}
```

***io类，用完就关。***

scanner.close();

### next方法

不能得到带有空格的字符串

### nextLine方法

使用回车键作为分隔符

# Java方法

## 什么是方法？

方法是语句的集合，解决一类问题的有序组合

包含于类或者对象当中

方法在程序中被创建，在其他地方被引用

（原子性）一般来说，一个方法仅仅执行一个功能

## 方法的定义及调用

> 包括修饰符，返回值类型，方法名（小驼峰），参数类型，方法体
>
> void不用使用return

Java 是值传递

## 方法的重载

名称必须相同

参数列表必须不同

返回值类型可以相同，也可以不同

## 命令行传参

注意依赖包的相对位置

## 可变参数

在方法声明中，在变量类型后面添加。。。

可变参数是多个同类型参数时使用

## 递归

能不用就不用

# 数组

相同类型的有序集合

相同类型的若干个数据，按照移动的前后次序排序组合

每一个成为一个元素，每个数组的下表从0开始

## 声明与创建

1. 变量类型 变量的名字 = 变量的值

   int【】 nums；

   int num2【】；（来自c++）

2. 初始化

   1. 静态初始化

   ```java
   int[] a={1,2,3,4,5}
   ```

   2. 动态初始化

   ```java
   int[] = new int[10];
   ```

3. 数组的特点
   1. 数组里的元素类型一致
   2. 数组是一个对象
   3. 数组的长度不可变更

# OOP 面向对象

封装

## 继承 extends

### Super 

注意点

1. super调用父类的构造方法，必须在构造方法中的第一个
2. super必须并且只能出现在子类的方法或者构造方法中
3. super和this不能同时调用构造方法

this 本身调用这个对象

​	没有继承也可以使用

​	this（）本类的构造

super 代表父类对象的应用

​	只能在继承条件下使用

​	父类的构造

### 继承的重写

重写都是方法的重写，与修饰词无关

父类的引用指向了子类，方法的调用只和左边的数据类型有关

1. 重写需要有继承关系，子类重写父类的方法

2. 方法名必须相同

3. 参数列表必须相同

4. 修饰符可以扩大，但是不可以缩小 

   **private**《**default**〈**protected**《**public**

5. 抛出的异常，范围可以缩小但是不能扩大

### 多态

1. 多态是方法的多态，属性没有多态；
2. 父类和自类有联系，有可能出现类型转换异常（*ClassCast Exception*）
3. 继承关系，方法需要重写，父类引用指向子类对象
4. 有的方法不能被重写
   1. static 方法，属于类，不属于实例
   2. final 常量
   3. private

## 静态static

静态属性：类属性，可以直接在类中调用，不需要new对象

非静态的可以调用静态的

静态的不可以调用非静态的

静态代码块》匿名代码块〉构造方法

静态代码块仅执行一次

匿名代码块：用来赋值的好东西

静态导入包

final没有子类

## 抽象abstract

抽象类：只有方法名没有方法体

1. 抽象类的所有方法，继承其的子类都必须实现它的方法
2. 不能通过new来实例化
3. 只能通过继承
4. 抽象方法必须在抽象类里，抽象类里可以有抽象方法

## 接口interface

*没有构造方法*

**接口可以实现多继承**，**接口的本质是契约**

只有规范，没有方法，只有约束，约束和实现分离

声明修饰词interface

方法默认是public abstract，属性是常量public static final

接口都需要实现类impl结尾

## 实现类implements

类可以实现接口

实现接口的类，就必须重写接口中的方法

可以利用接口实现多继承

## 内部类

####  成员内部类

内部类访问外部类的私有属性，操作内部类

通过先实例化外部类在。new出内部类

#### 静态内部类

就无法访问外部动态属性

一个.java中只能有一个public class，但是可以有多个class

#### 局部内部类

在方法中的class

#### 匿名内部类

直接new出来，不引用

# Exception异常

## 定义

突发没有遇见的时间

## 体系结构

Throwable 所有异常的超类

分为error和exception

exp中一类分为运行时异常，一类分为非运行时异常（检查性错误）

## 异常处理机制

try「监控区域」

​	catch（异常类型 e）「代码块」

​	catch（）「」

​	catch（）「」（下方的异常类型应该最大）

​	finally「代码块」【这个小家伙可以不要，但是在IO里面对资源的调用执行善后工作（关闭）】

## 处理异常

主动抛出异常

throw new 异常类型，一般在方法中使用

throws和try catch对应，一个不解决，一个要解决

## 自定义异常

继承与异常类

构造器

to String返回消息

## 总结 

1. 运行时异常，try-catch
2. 多catch，用一个大类型的异常
3. 对于不确定的，加上try-catch
4. 尽可能去处理异常，而不是简单的打印出来
5. 尽量添加finally去释放占用的资源

